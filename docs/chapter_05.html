<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Structs to Structure Related Data - Study: Rust Programming Language 2nd edition</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li class="chapter-item expanded "><a href="chapter_05.html" class="active"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> More About Cargo and Crates.io</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> Object-Oriented Programming Features</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Rust Programming Language 2nd edition</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/rust_lang_book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-structs-to-structure-related-data"><a class="header" href="#using-structs-to-structure-related-data">Using Structs to Structure Related Data</a></h1>
<p>A <code>struct</code>, or structure, is a custom data type that lets you package together and name multiple related values that
make up a meaningful group. If you're familiar with an object-oriented language, a <code>struct</code> is like an object's data
attributes. In this chapter, we'll compare and contrast tuples with structs to build on what you already know and
demonstrate when struts are a better way to group data.</p>
<p>We'll demonstrate how to define and instantiate structs. We'll discuss how to define associated functions, especially
the kind of associated functions called methods, to specify behavior associated with a struct type. Structs and enums (
discussed in Chapter 6) are the building blocks for creating new types in your program's domain to take full advantage
of Rust's compile-time type checking.</p>
<h2 id="defining-and-instantiating-structs"><a class="header" href="#defining-and-instantiating-structs">Defining and Instantiating Structs</a></h2>
<p>Structs are similar to tuples, discussed in &quot;The Tuple Type&quot;, in that both hold multiple related values. Like tuples,
the pieces of a struct can be different types. Unlike with tuples, in a struct you'll name each piece of data so it's
clear what the value mean. Adding these names means that structs are more flexible than tuples: you don't have to rely
on the order of the data to specify or access the values of an instance.</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A struct's name should describe the
significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call fields. For example, Listing 5-1 shows a struct that stores information about a user
account.</p>
<pre><code class="language-rust  noplayground">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<ul>
<li>Listing 5-1: A User struct definition</li>
</ul>
<p>To use a struct after we've defined it, we create an instance of that struct by specifying concrete values for each of
the fields. We create an instance by stating the name of the struct and then add curly brackets containing <code>key: value</code>
pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don't
have to specify the fields in the same order in which we declared them in the struct. In other words, the struct
definition is like a general template for the type, and instances fill in that template with particular data to create
values of the type. For example, we can declare a particular user as shown in Listing 5-2.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };
}</code></pre></pre>
<p>To get a specific value from a struct, we use dot notation. For example, to access this user's email address, we
use <code>user1.email</code>. If the instance is mutable, we can change a value by using the dot notation and assigning into a
particular field. Listing 5-3 shows how to change the value in the <code>email</code> field of a mutable <code>User</code> instance.</p>
<pre><code class="language-rust  noplayground"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
<span class="boring">        active: true,
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}</span></code></pre>
<p>Note that the entire instance must be mutable; Rust doesn't allow us to mark only certain fields as mutable. As with any
expression, we can construct a new instance of the struct as the last expression in the function body to implicitly
return that new instance.</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with the given email and username. The <code>active</code>
field gets the value of <code>true</code>, and the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<pre><code class="language-rust  noplayground"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<ul>
<li>Listing 5-4: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance</li>
</ul>
<p>It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the <code>email</code>
and <code>username</code> field names and variables is a bit tedious. If the struct had more fields, repeating each name would get
even more annoying. Luckily, there's a convenient shorthand!</p>
<h3 id="using-the-field-init-shorthand"><a class="header" href="#using-the-field-init-shorthand">Using the Field Init Shorthand</a></h3>
<p>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the field init
shorthand syntax to rewrite <code>build_user</code> so it behaves exactly the same but doesn't have the repetition of <code>username</code>
and <code>email</code>, as shown in Listing 5-5.</p>
<pre><code class="language-rust  noplayground">fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}</code></pre>
<ul>
<li>Listing 5-5: A <code>build_user</code> function that uses field init shorthand because the <code>username</code> and <code>email</code> parameters have
the same name as <code>struct</code> fields</li>
</ul>
<p>Here, we're creating a new instance of the <code>User</code> struct, which has a field named <code>email</code>. We want to set the <code>email</code>
field's value to the value in the <code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and
the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather than <code>email: email</code>.</p>
<h3 id="creating-instances-from-other-instances-with-struct-update-syntax"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax">Creating Instances from Other Instances with Struct Update Syntax</a></h3>
<p>It's often useful to create a new instance of a struct that includes most of the values from another instance, but
changes some. You can do this using struct update syntax.</p>
<p>First, in Listing 5-6 we show how to create a new <code>User</code> instance in <code>user2</code> regularly, without the update syntax. We
set a new value for <code>email</code> but otherwise use the same values from <code>user1</code> that we created in Listing 5-2.</p>
<pre><code class="language-rust  noplayground"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_user(email: String, username: String) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        active: true,
</span><span class="boring">        username: username,
</span><span class="boring">        email: email,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut user1 = User {
</span><span class="boring">        active: true,
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    user1.email = String::from(&quot;anotheremail@example.com&quot;);
</span><span class="boring">    
</span>    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}</span></code></pre>
<ul>
<li>Listing 5-6: Creating a new <code>User</code> instance using one of the values from <code>user1</code></li>
</ul>
<p>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax <code>..</code>
specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</p>
<pre><code class="language-rust  noplayground"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut user1 = User {
</span><span class="boring">        active: true,
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    user1.email = String::from(&quot;anotheremail@example.com&quot;);
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
<span class="boring">}</span></code></pre>
<ul>
<li>Listing 5-7: Using struct update syntax to set a new <code>email</code> value for a <code>User</code> instance but to use the rest of the
values from <code>user1</code></li>
</ul>
<p>The code in Listing 5-7 also creates an instance in <code>user2</code> that has a different value for <code>email</code> but has the same
values for the <code>username</code>, <code>active</code>, and <code>sign_in_count</code> fields from <code>user1</code>. The <code>..user1</code> must come last to specify
that any remaining fields should get their values from the corresponding fields in <code>user1</code>, but we can choose to specify
values for as many fields as we want in any order, regardless of the order of the fields in the struct's definition.</p>
<p>Note that the struct update syntax uses <code>=</code> like an assignment; this is because it moves the data, just as we saw in &quot;
Variables and Data Interacting with Move&quot;. In this example, we can no longer use <code>user1</code> after creating <code>user2</code> because
the <code>String</code> in the <code>username</code> field of <code>user1</code> was moved into <code>user2</code>. If we had given <code>user2</code> new <code>String</code> values for
both <code>email</code> and <code>username</code>, and thus only used the <code>active</code> and <code>sign_in_count</code> values from <code>user1</code>, then <code>user1</code> would
still be valid after creating <code>user2</code>. Both <code>active</code> and <code>sign_in_count</code> are types that implement the <code>Copy</code> trait, so
the behavior we discussed in &quot;Stack-Only Data: Copy&quot; would apply.</p>
<h3 id="using-tuple-structs-without-named-fields-to-create-different-types"><a class="header" href="#using-tuple-structs-without-named-fields-to-create-different-types">Using Tuple Structs Without Named Fields to Create Different Types</a></h3>
<p>Rust also supports structs that look similar to tuples, called tuple structs. Tuple structs have the added meaning the
struct name provides but don't have names associated with their fields; rather, they just have the types of the fields.
Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other
tuples, and when naming each field as in a regular struct would be verbose or redundant.</p>
<p>To define a tuple struct, start with the <code>struct</code> keyword and the struct name followed by the types in the tuple. For
example, here we define and use two tuple structs named <code>Color</code> and <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Note that the <code>black</code> and <code>origin</code> values are different types because they're instances of different tuple structs. Each
struct you define is its own type, even though the fields within the struct might have the same types. For example, a
function that takes a parameter of type <code>Color</code> cannot take a <code>Point</code> as an argument, even though both types are made up
of three <code>i32</code> values. Otherwise, tuple struct instances are similar to tuples in that you can destructure them into
their individual pieces, and you can use a <code>.</code> followed by the index to access an individual value.</p>
<h3 id="unit-like-structs-without-any-fields"><a class="header" href="#unit-like-structs-without-any-fields">Unit-Like Structs Without Any Fields</a></h3>
<p>You can also define structs that don't have any fields! These are called unit-like structs because they behave similarly
to <code>()</code>, the unit type that we mentioned the &quot;The Tuple Type&quot;. Unit-like structs can be useful when you need to
implement a trait on some type but don't have any data that you want to store in the type itself. We'll discuss traits
in Chapter 10. Here's an example of declaring and instantiating a unit struct named <code>AlwaysEqual</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>To define <code>AlwaysEqual</code>, we use the <code>struct</code> keyword, the name we want, and then a semicolon. No need for curly brackets
or parentheses! Then we can get an instance of <code>AlwaysEqual</code> in the <code>subject</code> variable in a similar way: using the name
we defined, without any curly brackets or parentheses. Imagine that later we'll implement behavior for this type such
that every instance of <code>AlwaysEqual</code> is always equal to every instance of any other type, perhaps to have a known result
for testing purposes. We wouldn't need any data to implement that behavior! You'll see in Chapter 10 how to define
traits and implement them on any type, including unit-like structs.</p>
<blockquote>
<h4 id="ownership-of-struct-data"><a class="header" href="#ownership-of-struct-data">Ownership of Struct Data</a></h4>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code> type rather than the <code>&amp;str</code> string slice
type. This is a deliberate choice because we want each instance of this struct to own all of its data and for that data
to be valid for as long as the entire struct is valid.</p>
<p>It's also possible for structs to store references to data owned by something else, but to do so requires the use of
lifetimes, a Rust feature that we'll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is
valid for as long as the struct is. Let's say you try to store a reference in a struct without specifying lifetimes,
like the following in <code>src/main.rs</code>; this won't work:</p>
<pre><code class="language-rust  noplayground">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;someusername123&quot;,
        email: &quot;someone@example.com&quot;,
        sign_in_count: 1,
    };
}</code></pre>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<pre><code class="language-text">$ cargo run
   Compiling listing_5_4 v0.1.0 (C:\Users\jerok\projects\study_blog\rust_lang_book\code\ch05\listing_5_4)
error[E0106]: missing lifetime specifier                                                                  
  --&gt; src\main.rs:21:15
   |
21 |     username: &amp;str,
   |               ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
19 ~ struct User&lt;'a&gt; {
20 |     active: bool,
21 ~     username: &amp;'a str,
   |

error[E0106]: missing lifetime specifier
  --&gt; src\main.rs:22:12
   |
22 |     email: &amp;str,
   |            ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
19 ~ struct User&lt;'a&gt; {
20 |     active: bool,
21 |     username: &amp;str,
22 ~     email: &amp;'a str,
   |
</code></pre>
<p>In Chapter 10, we'll discuss how to fix these errors so you can store references in structs, but for now, we'll fix
errors like these using owned types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
</blockquote>
<h2 id="an-example-program-using-structs"><a class="header" href="#an-example-program-using-structs">An Example Program Using Structs</a></h2>
<p>To understand when we might want to use structs, let's write a program that calculates the area of a rectangle. We'll
start by using single variables, and then refactor the program until we're using structs instead.</p>
<p>Let's make a new binary project with Cargo called <code>rectangles</code> that will take the width and height of a rectangle
specified in pixels and calculate the area of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project's <code>src/main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<ul>
<li>Listing 5-8: Calculating the area of a rectangle specified by separate width and height variables</li>
</ul>
<p>This code succeeds in figuring out the area of the rectangle by calling the <code>area</code> function with each dimension, but we
can do more to make this code clear and readable.</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<pre><code class="language-rust  noplayground">fn area(width: u32, height: u32) -&gt; u32 {</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters,
and it's not clear anywhere in our program that the parameters are related. It would be more readable and more
manageable to group width and height together. We've already discussed one way we might do that in &quot;The Tuple Type&quot;: by
using tuples.</p>
<h3 id="refactoring-with-tuples"><a class="header" href="#refactoring-with-tuples">Refactoring with Tuples</a></h3>
<p>Listing 5-9 shows another version of our program that uses tuples.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)                         // 1
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1             // 2
}</code></pre></pre>
<ul>
<li>Listing 5-9: Specifying the width and height of the rectangle with a tuple</li>
</ul>
<p>In one way, this program is better. Tuples let us add a bit of structure, and we're now passing just one argument (1).
But in another way, this version is less clear: tuples don't name their elements, so we have to index into the parts of
the tuple (2), making our calculation less obvious.</p>
<p>Mixing up the width and height wouldn't matter for the area calculation, but if we want to draw the rectangle on the
screen, it would matter! We would have to keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple
index <code>1</code>. This would be even harder for someone else to figure out and keep in mind if they were to use our code.
Because we haven't conveyed the meaning of our data in our code, it's now easier to introduce errors.</p>
<h3 id="refactoring-with-structs-adding-more-meaning"><a class="header" href="#refactoring-with-structs-adding-more-meaning">Refactoring with Structs: Adding More Meaning</a></h3>
<p>We use structs to add meaning by labeling the data. We can transform the tuple we're using into a struct with a name for
the whole as well as names for the parts, as shown in Listing 5-10.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">struct Rectangle {      // 1
    width: u32,         // 2
    height: u32,
}

fn main() {
    let rect1 = Rectangle {     // 3
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {     // 4
    rectangle.width * rectangle.height      // 5
}</code></pre></pre>
<ul>
<li>Listing 5-10: Defining a <code>Rectangle</code> struct</li>
</ul>
<p>Here, we've defined a struct and named it <code>Rectangle</code> (1). Inside the curly brackets, we defined the fields as <code>width</code>
and <code>height</code>, both of which have type <code>u32</code> (2). Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code> that
has a width of 30 and a height of 50 (3).</p>
<p>Our <code>area</code> function is now defined with one parameter, which we've named <code>rectangle</code>, whose type is an immutable borrow
of a struct <code>Rectangle</code> instance (4). As mentioned in Chapter 4, we want to borrow the struct rather than take ownership
of it. This way, <code>main</code> retains its ownership and can continue using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the
function signature and where we call the function.</p>
<p>The <code>area</code> function accesses the <code>width</code> and <code>height</code> fields of the <code>Rectangle</code> instance (5) (note that accessing fields
of a borrowed struct instance does not move the field values, which is why you often see borrows of structs). Our
function signature for <code>area</code> now says exactly what we mean: calculate the area of <code>Rectangle</code>, using its <code>width</code>
and <code>height</code> fields. This conveys that the width and height are related to each other, and it gives descriptive names to
the values rather than using the tuple index values of 0 and 1. This is a win for clarity.</p>
<h3 id="adding-useful-functionality-with-derived-traits"><a class="header" href="#adding-useful-functionality-with-derived-traits">Adding Useful Functionality with Derived Traits</a></h3>
<p>It'd be useful to be able to print an instance of <code>Rectangle</code> while we're debugging our program and see the values for
all its fields. Listing 5-11 tries using the <code>println!</code> macro as we have used in previous chapters. This won't work,
however.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    println!(&quot;rect1 is {}&quot;, rect1);
}</code></pre></pre>
<p>When we compile this code, we get an error with this core message:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, the curly brackets tell <code>println!</code> to use
formatting known as <code>Display</code>: output intended for direct end user consumption. The primitive types we've seen so far
implement <code>Display</code> by default because there's only one way you'd want to show a 1 or any other primitive type to a
user. But with structs, the way <code>println!</code> should format the output is less clear because there are more display
possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due
to this ambiguity, Rust doesn't try to guess what we want, and structs don't have a provided implementation of <code>Display</code>
to use with <code>println!</code> and the <code>{}</code> placeholder.</p>
<p>If we continue reading the errors, we'll find this helpful note:</p>
<pre><code class="language-text">= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Let's try it! The <code>println!</code> macro call will now look like <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>. Putting the
specifier <code>:?</code> inside the curly brackets tells <code>println!</code> we want to use an output format called <code>Debug</code>. The <code>Debug</code>
trait enables us to print our struct in a way that is useful for developers so we can see its value while we're
debugging our code.</p>
<p>Compile the code with this change. Drat! We still get an error:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>But again, the compiler gives us a helpful note:</p>
<pre><code class="language-text">= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust does include functionality to print out debugging information, but we have to explicitly opt in to make that
functionality available for our struct. To do that, we add the outer attribute <code>#[derive(Debug)]</code> just before the struct
definition, as shown in Listing 5-12.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}</code></pre></pre>
<ul>
<li>Listing 5-12: Adding the attribute to derive the <code>Debug</code> trait and printing the <code>Rectangle</code> instance using debug
formatting</li>
</ul>
<p>Now when we run the program, we won't get any errors, and we'll see the following output:</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Nice! It's not the prettiest output, but it shows the values of all the fields for this instance, which would definitely
help during debugging. When we have larger structs, it's useful to have output that's a bit easier to read; in those
cases, we can use <code>{:#?}</code> instead of <code>{:?}</code> in the <code>println!</code> string. In this example, using the <code>{:#?}</code> style will
output the following:</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Another way to print out a value using the <code>Debug</code> format is to use the <code>dbg!</code> macro, which takes ownership of an
expression (as opposed to <code>println!</code>, which takes a reference), prints the file and line number of where that <code>dbg!</code>
macro call occurs in your code along with the resultant value of that expression, and returns ownership of the value.</p>
<blockquote>
<p>Calling the <code>dbg!</code> macro prints to the standard error console stream (<code>stderr</code>), as opposed to <code>println!</code>, which
prints to the standard output console stream (<code>stdout</code>). We'll talk more about <code>stderr</code> and <code>stdout</code> in &quot;Writing Error
Messages to Standard Error Instead of Standard Output&quot;.</p>
</blockquote>
<p>Here's an example where we're interested in the value that gets assigned to the <code>width</code> field, as well as the value of
the whole struct in <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),    // 1
        height: 50,
    };
    
    dbg!(&amp;rect1);       // 2
}</code></pre></pre>
<p>We can put <code>dbg!</code> around the expression <code>30 * scale</code> (1) and, because <code>dbg!</code> returns ownership of the expression's
value, the <code>width</code> field will get the same value as if we didn't have the <code>dbg!</code> call there. We don't want <code>dbg!</code> to
take ownership of <code>rect1</code>, so we use a reference to <code>rect1</code> in the next call (2). Here's what the output of this example
looks like:</p>
<pre><code class="language-text">[src\main.rs:27] 30 * scale = 60
[src\main.rs:31] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>We can see the first bit of output came from (1) where we're debugging the expression <code>30 * scale</code>, and its resultant
value is 60 (the <code>Debug</code> formatting implemented for integers is to print only their value). The <code>dbg!</code> call at (2)
outputs the value of <code>&amp;rect1</code>, which is the <code>Rectangle</code> struct. This output uses the pretty <code>Debug</code> formatting of
the <code>Rectangle</code> type. The <code>dbg!</code> macro can be really helpful when you're trying to figure out what your code is doing!</p>
<p>In addition to the <code>Debug</code> trait, Rust has provided a number of traits for us to use with the <code>derive</code> attribute that
can add useful behavior to our custom types. Those traits and their behaviors are listed in Appendix C. We'll cover how
to implement these traits with custom behavior as well as how to create your own traits in Chapter 10. There are also
many attributes other than <code>derive</code>; for more information, see the &quot;Attributes&quot; section of the Rust Reference
at https://doc.rust-lang.org/reference/attributes.html.</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles. It would be helpful to tie this behavior
more closely to our <code>Rectangle</code> struct because it won't work with any other type. Let's look at how we can continue to
refactor this code by turning the <code>area</code> function into an <code>area</code> method defined on our <code>Rectangle</code> type.</p>
<h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<p>Methods are similar to functions: we declare them with the <code>fn</code> keyword and a name, they can have parameters and a
return value, and they contain some code that's run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum or a trait object, which we cover in Chapter 6 and
Chapter 17, respectively), and their first parameter is always <code>self</code>, which represents the instance of the struct the
method is being called on.</p>
<h3 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h3>
<p>Let's change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter and instead make an <code>area</code> method
defined on the <code>Rectangle</code> struct, as shown in Listing 5-13.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {                    // 1
    fn area(&amp;self) -&gt; u32 {         // 2
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()        // 3
    );
}</code></pre></pre>
<ul>
<li>Listing 5-13: Defining an <code>area</code> method on the <code>Rectangle</code> struct</li>
</ul>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>(implementation) block for <code>Rectangle</code> (1).
Everything within this <code>impl</code> block will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function
within the <code>impl</code> curly brackets (2) and change the first (and in this case, only) parameter to be <code>self</code> in the
signature and everywhere with the body. In <code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an
argument, we can instead use method syntax to call the <code>area</code> method on our <code>Rectangle</code> instance (3). The method syntax
goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle</code>: <code>&amp;Rectangle</code>. The <code>&amp;self</code> is actually short
for <code>self</code>: <code>&amp;Self</code>. Within an <code>impl</code> block, the type <code>Self</code> is an alias for the type that the <code>impl</code> block is for.
Methods must have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust lets you abbreviate this
with only the name <code>self</code> in the first parameter spot. Note that we still need to use the <code>&amp;</code> in front of the <code>self</code>
shorthand to indicate that this method borrows the <code>Self</code> instance, just as we did in <code>rectangle</code>: <code>&amp;Rectangle</code>. Methods
can take ownership of <code>self</code>, borrow <code>self</code> immutably, as we've done here, or borrow <code>self</code> mutably, just as they can
any other parameter.</p>
<p>We chose <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the function version: we don't want to take ownership,
and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we've called
the method on as part of what the method does, we'd use <code>&amp;mut self</code> as the first parameter. Having a method that takes
ownership of the instance by using just <code>self</code> as the first parameter is rare; this technique is usually used when the
method transforms <code>self</code> into something else and you want to prevent the caller from using the original instance after
the transformation.</p>
<p>The main reason for using methods instead of functions, in addition to providing method syntax and not having to repeat
the type of <code>self</code> in every method's signature, is for organization. We've put all the things we can do with an instance
of a type in one <code>impl</code> block rather than making future users of our code search for capabilities of <code>Rectangle</code> in
various places in the library we provide.</p>
<p>Note that we can choose to give a method the same name as one of the struct's fields. For example, we can define a
method on <code>Rectangle</code> that is also named <code>width</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(
            &quot;The rectangle has a nonzero width; it is {}&quot;,
            rect1.width
        );
    }
}</code></pre></pre>
<p>Here, we're choosing to make the <code>width</code> method return <code>true</code> if the value in the instance's <code>width</code> field is greater
than 0 and <code>false</code> if the value is 0: we can use a field within a method of the same name for any purpose. In <code>main</code>,
when we follow <code>rect1.width</code> with parentheses, Rust knows we mean the method <code>width</code>. When we don't use parentheses,
Rust knows we mean the field <code>width</code>.</p>
<p>Often, but not always, when we give methods with the same name as a field we want it to only return the value in the
field and do nothing else. Methods like this are called getters, and Rust does not implement them automatically for
struct fields as some other languages do. Getters are useful because you can make the field private but the method
public, and thus enable read-only access to that field as part of the type's public API. We will discuss what public and
private are and how to designate a field or method as public or private in Chapter 7.</p>
<blockquote>
<h4 id="wheres-the---operator"><a class="header" href="#wheres-the---operator">Where's the <code>-&gt;</code> operator?</a></h4>
<p>In C and C++, two different operators are used for calling methods: you use <code>.</code> if you're calling a method on the
object directly and <code>-&gt;</code> if you're calling the method on a pointer to the object and need to dereference the pointer
first. In other words, if <code>object</code> is a pointer, <code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>Rust doesn't have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a featured called automatic referencing and
dereferencing. Calling methods is one of the few places in Rust that has this behavior.</p>
<p>Here's how it works: when you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code>
so <code>object</code> matches the signature of the method. In other words, the following are the same:</p>
<pre><code class="language-rust  noplayground">p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);</code></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver -
the type of <code>self</code>. Given the receiver and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact that Rust makes borrowing implicit for method
receivers is a big part of making ownership ergonomic in practice.</p>
</blockquote>
<h3 id="methods-with-more-parameters"><a class="header" href="#methods-with-more-parameters">Methods with More Parameters</a></h3>
<p>Let's practice using methods by implementing a second method on the <code>Rectangle</code> struct. This time we want an instance
of <code>Rectangle</code> to take another instance of <code>Rectangle</code> and return <code>ture</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code> (the first <code>Rectangle</code>); otherwise, it should return <code>false</code>. That is, once we've defined the <code>can_hold</code>
method, we want to be able to write the program shown in Listing 5-14.</p>
<pre><code class="language-rust  noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect2 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}</code></pre>
<ul>
<li>Listing 5-14: Using the as-yet-unwritten <code>can_hold</code> method</li>
</ul>
<p>The expected output would look like the following because both dimensions of <code>rect1</code>, but <code>rect3</code> is wider than <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect2 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code> block. The method name will be <code>can_hold</code>,
and it will take an immutable borrow of nother <code>Rectangle</code> as a parameter. We can tell what the type of the parameter
will be by looking at the code that calls the method: <code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable
borrow to <code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to read <code>rect2</code> (rather than write,
which would mean we'd need a mutable borrow), and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again
after calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a Boolean, and the implementation will check
whether the width and height of <code>self</code> are greater than the width and height of the other <code>Rectangle</code>, respectively.
Let's add the new <code>can_hold</code> method to the <code>impl</code> block from Listing 5-13, shown in Listing 5-15.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect2 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}</code></pre></pre>
<ul>
<li>Listing 5-15: Implementing the <code>can_hold</code> method on <code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</li>
</ul>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we'll get our desired output. Methods can take multiple
parameters that we add to the signature after the <code>self</code> parameter, and those parameters work just like parameters in
functions.</p>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h3>
<p>All functions defined within an <code>impl</code> block are called associated functions because they're associated with the type
named after the <code>impl</code>. We can define associated functions that don't have <code>self</code> as their first parameter (and thus are
not methods) because they don't need an instance of the type to work with. We've already used one function like this:
the <code>String::from</code> function that's defined on the <code>String</code> type.</p>
<p>Associated functions that aren't methods are often used for constructors that will return a new instance of the struct.
These are often called <code>new</code>, but <code>new</code> isn't a special name and isn't built into the language. For example, we could
choose to provide an associated function named <code>square</code> that would have one dimension parameter and use that as both
width and height, thus making it easier to create a square <code>Rectangle</code> rather than having to specify the same value
twice:</p>
<pre><code class="language-rust  noplayground">impl Rectangle {
    fn square(size: u32) -&gt; Self {  // 1
        Self {                      // 2
            width: size,
            height: size,
        }
    }
}</code></pre>
<p>The <code>Self</code> keywords in the return type (1) and in the body of the function (2) are aliases for the type that appears
after the <code>impl</code> keyword, which in this case is <code>Rectangle</code>.</p>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name; <code>let sq = Rectangle::square(3);</code> is an
example. This function is namespaced by the struct: the <code>::</code> syntax is used for both associated functions and namespaces
created by modules. We'll discuss modules in Chapter 7.</p>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple impl Blocks</a></h3>
<p>Each struct is allowed to have multiple <code>impl</code> blocks. For example, Listing 5-15 is equivalent to the code shown in
Listing 5-16, which has each method in its own <code>impl</code> block.</p>
<pre><code class="language-rust  noplayground">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<ul>
<li>Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code> blocks</li>
</ul>
<p>There's no reason to separate these methods into multiple <code>impl</code> blocks here, but this is valid syntax. We'll see a case
in which multiple <code>impl</code> blocks are useful in Chapter 10, where we discuss generic types and traits.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By using structs, you can keep associated
pieces of data connected to each other and name each piece to make your code clear. In <code>impl</code> blocks, you can define
functions that are associated with your type, and methods are a kind of associated function that let you specify the
behavior that instances of your structs have.</p>
<p>But structs aren't the only way you can create custom types: let's turn to Rust's enum feature to add another tool to
your toolbox. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_04.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter_06.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_04.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter_06.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
